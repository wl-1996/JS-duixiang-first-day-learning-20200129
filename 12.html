<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>原型prototype</title>
</head>
<body>

<script>
    // 任何函数都有原型，如果函数是普通函数，那么它的原型没有任何鸟用
    // function fun(){
    //     alert("你好")
    // }
    //
    // console.log(fun.prototype)
    // console.log(typeof fun.prototype)

    //=======================
    //构造函数，构造函数里面没有任何语句，也就是说，这个构造函数在执行的时候，不会给创建出来的对象添加任何属性。
    function People() {
        this.name = "小明"
    }

    //构造函数的原型，我们更改了构造函数的原型，为一个新的对象：
    People.prototype = {
        name: "考拉",
        sex: "男",
        age: 18
    }

    //当一个对象被new出来的时候，不仅仅执行了构造函数里面的语句，也会把这个函数的__proto__指向构造函数的prototype。
    let xiaoming = new People()

    console.log(xiaoming.__proto__)
    console.log(xiaoming.__proto__ == People.prototype)

    //当我们试图访问sex、age属性的时候，身上没有。那么就去查找原型，原型身上有，就当做了自己的属性返回了。
    console.log(xiaoming.name)//name自己有，就返回自己的属性
    console.log(xiaoming.sex)//自己没有，找原型对象
    console.log(xiaoming.age)//自己没有，找原型对象
</script>
</body>
</html>